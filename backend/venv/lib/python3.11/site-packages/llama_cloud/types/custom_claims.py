# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

from ..core.datetime_utils import serialize_datetime

try:
    import pydantic
    if pydantic.__version__.startswith("1."):
        raise ImportError
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore


class CustomClaims(pydantic.BaseModel):
    """
    Custom claims that dictate various limits or allowed behaviors.
    Currently these claims reside at a per user level. Claims may expand to a per organization level or project in the future.
    """

    allowed_index: typing.Optional[bool] = pydantic.Field(
        description="Whether the user is allowed to access the index."
    )
    allowed_playground: typing.Optional[bool] = pydantic.Field(description="Deprecated. Use allowed_index instead")
    usage_pdf_max_pages_per_day: typing.Optional[int] = pydantic.Field(
        description="The maximum number of PDF pages the user can generate per day."
    )
    parse_premium: typing.Optional[bool] = pydantic.Field(
        description="Whether the user has a LlamaParse premium claim."
    )
    usage_index_max_files_per_pipeline: typing.Optional[int] = pydantic.Field(
        description="The maximum number of files per pipeline the user can index without LlamaParse premium."
    )
    max_jobs_in_execution_per_job_type: typing.Optional[int] = pydantic.Field(
        description="The maximum number of jobs the user can have in execution per job type."
    )
    max_document_ingestion_jobs_in_execution: typing.Optional[int] = pydantic.Field(
        description="The maximum number of document ingestion jobs the user can have in execution."
    )
    allowed_extraction: typing.Optional[bool] = pydantic.Field(
        description="Whether the user is allowed to use structured data extraction features."
    )
    allowed_eval: typing.Optional[bool] = pydantic.Field(description="Whether the user is allowed to run evals.")

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        smart_union = True
        json_encoders = {dt.datetime: serialize_datetime}
